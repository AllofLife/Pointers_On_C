# Pointers_On_C　第一章
# 笔记
1、函数read_column_numbers(int columns[],int max)
# 参数
	 函数的第一个参数是一个数组，传递的是数组的首地址，注意：这个数组并没有声明数组的大小
	这意味着如果我们在函数内部使用了这个数组，他可以是无限大的一维数组。如果我们要让这个
	数组的大小固定，我们需要另外添加一个参数来确定数组的大小。
# 内部
	 int num = 0;
	 int ch;
	 num定义时赋值，ch定义时候没有赋值，那么它的值就是一个垃圾值
	 
	 数组在被引用时候，c编译器并不会对被引用的数组进行有效性检查。如果这个
	 数组已经满了，我们要再往里面添加东西，就会产生溢出。溢出也有其他的情况，根本
	 对并非数组的内存进行了操作。
	 比如定义 int a[10],
	 在引用时候写了：a[10] = 3;
	 程序在编译的时候不会报错，但是在运行的时候可能会报错，
	 对于上面的引用，我们可能会出现的错误是，将数组申请的内存之后的四个字节的内存
	 重写了一个值。那么原本这段内存的值就不存在了。（想写个程序来验证）
	 写完了，的确如我所想。（程序见test_full_arrary.c）
	 程序的可读性和维护性还有性能要综合考虑，如果不是非常影响性能的语句，宁愿多写几句也不使用各种技巧，
	 当然不是一根筋地这样做，也要综合考虑这个程序写出了可能有谁来读，不过即使是自己，也要对自己好点呀！
	 ch是一个int型变量，程序中用来接受一个字符型的值，int占4个字节（64位机器），char占一个字节，这是可以的，
	 但是这样有点浪费空间。程序中这样做的原因是EOF是一个int型，用来做异常处理的，如果输入存在任何的字符，
	 那么gitchar（）就会返回一个EOF
	 const 可以保护变量不被修改，我猜测是限制内存的操作，如果程序中有语句试图修改const修饰的变量，那么编译器就会报错！
	 注意这里是编译器报错，之前的数组访问是运行时候报错，而且不一定报错，但是const在编译期间有错就一定会报错！
	 
	 
	
