# Pointers_On_C　第一章
# 笔记
1、函数read_column_numbers(int columns[],int max)
## 参数
	 函数的第一个参数是一个数组，传递的是数组的首地址，注意：这个数组并没有声明数组的大小
	这意味着如果我们在函数内部使用了这个数组，他可以是无限大的一维数组。如果我们要让这个
	数组的大小固定，我们需要另外添加一个参数来确定数组的大小。
## 内部
	 int num = 0;
	 int ch;
	 num定义时赋值，ch定义时候没有赋值，那么它的值就是一个垃圾值
	 
	 数组在被引用时候，c编译器并不会对被引用的数组进行有效性检查。如果这个
	 数组已经满了，我们要再往里面添加东西，就会产生溢出。溢出也有其他的情况，根本
	 对并非数组的内存进行了操作。
	 比如定义 int a[10],
	 在引用时候写了：a[10] = 3;
	 程序在编译的时候不会报错，但是在运行的时候可能会报错，
	 对于上面的引用，我们可能会出现的错误是，将数组申请的内存之后的四个字节的内存
	 重写了一个值。那么原本这段内存的值就不存在了。（想写个程序来验证）
	 写完了，的确如我所想。（程序见test_full_arrary.c）
	 程序的可读性和维护性还有性能要综合考虑，如果不是非常影响性能的语句，宁愿多写几句也不使用各种技巧，
	 当然不是一根筋地这样做，也要综合考虑这个程序写出了可能有谁来读，不过即使是自己，也要对自己好点呀！
	 ch是一个int型变量，程序中用来接受一个字符型的值，int占4个字节（64位机器），char占一个字节，这是可以的，
	 但是这样有点浪费空间。程序中这样做的原因是EOF是一个int型，用来做异常处理的，如果输入存在任何的字符，
	 那么gitchar（）就会返回一个EOF
	 const 可以保护变量不被修改，我猜测是限制内存的操作，如果程序中有语句试图修改const修饰的变量，那么编译器就会报错！
	 注意这里是编译器报错，之前的数组访问是运行时候报错，而且不一定报错，但是const在编译期间有错就一定会报错！

## 问题解答： 
		1.空白规则是为了排版好看，不容易误解有的变量和函数，比如 int a=1；和 int a = 1; 明显后者更加的直观。
		2.头文件可以实现最多一次修改，把多个源文件需要用到的函数或者变量放到一个头文件里面，一般头文件有.h 就有 .cpp/.c 当然
		也有Eigen这样的只有头文件的库。
		3.#define 跟头文件有点相似，提高代码的维护性。对于常用的量，比如π 3.14这样的常亮，宏定义很适合。
		4.
		| 变量类型        | 符号   | 
		| --------   	 | -----:    | 
		| 十进制整数     | %d 		|  
		| 字符串        |   %s   	   |   
		| 浮点数        |    %f    	|
			5. scanf("%d%d%S",&quantity,&prise,department);
		6.不在编译的时候检查下标，链接的时候应该也不会吧，那么只有程序执行的时候才发现下标越界了或者别的啥问题。
		我觉得可能是检查下标需要时间，，，查询之后得到的结论是：一是为了执行效率，二是为了不削弱指针强大的功能！！
		7.strncopy和strcopy的区别在于前者指定了复制的长度（第三个参数决定），而后者是直接复制，有多长复制多长，而我们的题目是切片的。
		8.gets（）已经被淘汰了，取而代之的是fgets（），gets没有限制缓存区的大小有可能发生内存溢出，gcc已经不能编译他了。fgets（）会根据数组的大小限制缓冲区
		gets函数原型：char*gets(char*buffer);//读取字符到数组：gets(str);str为数组名。
		gets函数功能：从键盘上输入字符，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。
		读取的换行符被转换为null值，做为字符数组的最后一个字符，来结束字符串。
		注意：gets函数由于没有指定输入字符大小，所以会无限读取，一旦输入的字符大于数组长度，就会发生内存越界，从而造成程序崩溃或其他数据的错误。
		fgets函数原型：char *fgets(char *s, int n, FILE *stream);//我们平时可以这么使用：fgets(str, sizeof(str), stdin);
		其中str为数组首地址，sizeof(str)为数组大小，stdin表示我们从键盘输入数据。
		fgets函数功能：从文件指针stream中读取字符，存到以s为起始地址的空间里，知道读完N-1个字符，或者读完一行。
		注意：调用fgets函数时，最多只能读入n-1个字符。读入结束后，系统将自动在最后加'\0'，并以str作为函数值返回。
##编程练习
		1.print("hello,worlf\n");
		
		2.
		   #include<stdio.h>
		   #include<stdlib.h>
		   int main(void){
			int ch;
			int line;
			int at_begaining;

			line = 0;
			at_begaining = 1;
			/*
			** 读取字符并且逐一处理它们。
			*/
			while( (ch = getchar() ) != EOF){
			/*
			** 如果我们位于一行的起始位置，那么我们就打印行号
			*/
			if( at_begaining == 1 ){
				at_begaining = 0;
				line += 1;
				print(" % d ", line );
				/*
				** 打印字符，并且对行尾进行检查。
				*/
				putchar( ch );
				if( ch == '\n'  )
					at_begaining = 1;
			}
			}
			return EXIT_SUCCESS;
			}
			
			3.
		    #include<stdio.h>
		    #include<stdlib.h>
		    int main(void){
			char checksum;
			int ch;
			while( 	while( (ch = getchar() ) != EOF ){
				checksum = checksum +  ch;				
			)
			print("%d",check-'0')
			return EXIT_SUCCESS;
			}
			4.讲下思路吧，我需要的是 两个int 变量，不对，刚看了下是读取文件，找出文件最长的一行，把这行打印出来，那么就还需要记住这行的地址，又说了一行一行的读取，而不是整个文件读取进来，这样也好，不会因为文件大而把整个内存消耗的问题，一个记录最大值，另一个记录当前行的地址。写个伪代码吧（文件读取忘了！！）
			for（int i = 0 ; i < len( file ) ; i++ ）{
				if( current_file_length > maxlength )
					maxlength = current_file_length ;
					posion=i;									
			}
			5.简单的说下课后的这个答案吧：
			其实答案的思路很简单，将用户可能的所有输入情况考虑进去。
			在软件开发过程中也有这么一个考虑（我写网站的时候），解决的方法有两大类，一是把所有的可能结果罗列出来，一一进行编码判断，这就比较累哦，不过有些需求不得不这样实现。还一个就是考虑一部分主要的输入，对于一些特殊情况，我们就通过编码把这些情况剔除掉。课后题目答案是考虑了所有可能的输入，对他们进行了一一判断。
			6.这个简单，在最后的判断下不要吧最后一个数去掉，把最后一个数加上结尾的数进行配对输出。
